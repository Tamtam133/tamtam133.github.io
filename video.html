<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Puzzle English Clone</title>

  <link rel="stylesheet" href="styles.css" />

  <style>
    .player-container { position: relative; width: 640px; margin: 0 auto; }
    .player-wrap { width: 640px; height: 360px; }

    #dim-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.94);   /* ещё темнее */
      display: none;
      z-index: 9;
      pointer-events: none;
      backdrop-filter: blur(1.5px);
    }

    #puzzle-overlay {
      position: absolute;
      inset: 0;
      display: none;
      z-index: 10;
      pointer-events: none;
    }

    .puzzle-under {
      width: 640px;
      margin: 12px auto 0;
      background: rgba(0,0,0,0.04);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 10px;
      padding: 12px;
      box-sizing: border-box;
    }

    .puzzle-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .left-controls, .right-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn {
      padding: 8px 12px;
      background: #222;
      border: 1px solid #444;
      color: #fff;
      cursor: pointer;
      border-radius: 8px;
      font-size: 0.95em;
    }
    .btn:hover { background: #333; }
    .btn.secondary { background: #111; border-color: #333; opacity: 0.95; }
    .btn.secondary:hover { background: #1b1b1b; }

    .status {
      color: #444;
      font-size: 0.95em;
      max-width: 360px;
      line-height: 1.2;
    }

    .words-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 12px; }
    .word-btn {
      padding: 8px 15px;
      background: #444;
      border: 1px solid #666;
      color: white;
      cursor: pointer;
      border-radius: 8px;
      font-size: 1.05em;
    }
    .word-btn:hover { background: #666; }

    .result-area {
      min-height: 56px;
      border: 2px dashed rgba(0,0,0,0.18);
      border-radius: 10px;
      width: 100%;
      margin-bottom: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      padding: 8px;
      box-sizing: border-box;
      background: rgba(255,255,255,0.85);
    }

    .word-btn.used { opacity: 0.25; pointer-events: none; }
    .correct { color: #2e7d32; font-weight: 700; }
    .muted { opacity: 0.8; }
    .small { font-size: 0.92em; }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="container">
      <h1 class="site-title">Видео-паззл</h1>
    </div>
  </header>

  <main class="container">
    <section class="card">
      <div class="controls stack">
        <div class="row">
          <label class="field">
            <span class="label">ID или URL видео</span>
            <input id="vid" type="text" placeholder="dQw4w9WgXcQ" />
          </label>
          <button id="load">Загрузить видео</button>
        </div>

        <div class="row">
          <label class="field">
            <span class="label">Файл субтитров (.srt)</span>
            <input id="srtFile" type="file" accept=".srt" />
          </label>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="player-container">
        <div id="player" class="player-wrap"></div>
        <div id="dim-overlay"></div>
        <div id="puzzle-overlay"></div>
      </div>

      <div id="puzzle-under" class="puzzle-under" style="display:none;">
        <div class="puzzle-controls">
          <div class="left-controls">
            <button id="listen-btn" class="btn">Слушать фразу</button>
            <button id="listen-1s-btn" class="btn secondary">Повторить -1 сек.</button>
            <button id="skip-btn" class="btn secondary">Пропустить</button>
          </div>
          <div class="right-controls">
            <div id="feedback" class="status"></div>
          </div>
        </div>

        <div id="result-area" class="result-area"></div>
        <div id="words-pool" class="words-container"></div>
      </div>

      <p class="muted small">
        Загрузите видео и SRT файл. Видео остановится в конце каждой фразы, затем появятся слова для сборки.
      </p>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);

    let ytPlayer = null;
    let playerReady = false;

    let subtitles = [];
    let userSentence = [];

    let tickTimer = null;

    let snippetResumePuzzle = false;

    // какой субтитр следующий по порядку
    let nextIdx = 0;

    // какой паззл сейчас активен (важно для кнопок и solved)
    let activePuzzleIdx = null;

    // режим "прослушать отрывок"
    let snippetMode = false;
    let snippetEnd = 0;
    let snippetIdx = null;

    function showPuzzleUI(show) {
      $("puzzle-under").style.display = show ? "block" : "none";
      $("dim-overlay").style.display = show ? "block" : "none";
      $("puzzle-overlay").style.display = show ? "block" : "none";
    }

    function timeToSeconds(timeStr) {
      timeStr = timeStr.replace('.', ',');
      const [h, m, s] = timeStr.split(':');
      const [sec, ms] = s.split(',');
      return parseInt(h) * 3600 + parseInt(m) * 60 + parseInt(sec) + parseInt(ms) / 1000;
    }

    // максимально стабильный парсер SRT: split на блоки
    function parseSRT(data) {
      data = data
        .replace(/^\uFEFF/, '')        // убираем BOM (частая причина "пропала первая фраза")
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .trim();

      const blocks = data.split(/\n{2,}/);
      const result = [];

      for (const block of blocks) {
        const lines = block.split('\n').map(l => l.trim()).filter(Boolean);
        if (lines.length < 2) continue;

        // иногда в блоке нет номера, поэтому ищем строку со стрелкой
        const timeLineIndex = lines.findIndex(l => l.includes('-->'));
        if (timeLineIndex === -1) continue;

        const timeLine = lines[timeLineIndex];
        const m = timeLine.match(
          /(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})/
        );
        if (!m) continue;

        const start = timeToSeconds(m[1]);
        const end = timeToSeconds(m[2]);

        const textRaw = lines.slice(timeLineIndex + 1).join(' ');
        const clean = textRaw
          .replace(/<[^>]*>/g, '')           // убираем теги
          .replace(/[.,!?;:"“”(){}\[\]]/g, '') // мягкая чистка пунктуации
          .replace(/\s+/g, ' ')
          .trim();

        if (!clean) continue;

        result.push({ start, end, text: clean, solved: false });
      }

      result.sort((a, b) => a.start - b.start);

      alert(`Загружено фраз: ${result.length}`);
      return result;
    }

    function initPuzzleByIndex(idx) {
      if (idx == null || idx < 0 || idx >= subtitles.length) return;

      activePuzzleIdx = idx;
      const text = subtitles[idx].text;

      const words = text.split(/\s+/).filter(Boolean).sort(() => Math.random() - 0.5);

      userSentence = [];
      $("words-pool").innerHTML = '';
      $("result-area").innerHTML = '';
      $("feedback").textContent = '';

      showPuzzleUI(true);

      ytPlayer?.pauseVideo?.();

      // показываем слова
      for (const word of words) {
        const btn = document.createElement('button');
        btn.className = 'word-btn';
        btn.textContent = word;
        btn.onclick = () => {
          if (btn.classList.contains('used')) return;
          btn.classList.add('used');
          userSentence.push(word);
          renderUserSentence();
        };
        $("words-pool").appendChild(btn);
      }

      // маленькая подсказка, какую фразу собираем (можно убрать)
      $("feedback").innerHTML = `<span class="muted">Фраза #${idx + 1}/${subtitles.length}</span>`;
    }

    function syncNextIdxToTime(t) {
  if (!subtitles.length) {
    nextIdx = 0;
    return;
  }
  nextIdx = 0;
  // пропускаем все фразы, которые уже закончились к текущему времени
  while (nextIdx < subtitles.length && subtitles[nextIdx].end <= t + 0.05) {
    nextIdx++;
  }
}

    function renderUserSentence() {
      const originalText = subtitles[activePuzzleIdx]?.text ?? '';
      $("result-area").innerHTML = '';
      for (const word of userSentence) {
        const span = document.createElement('span');
        span.className = 'word-btn';
        span.textContent = word;
        $("result-area").appendChild(span);
      }

      if (userSentence.join(' ') === originalText) {
        $("feedback").innerHTML = '<span class="correct">Правильно!</span>';

        setTimeout(() => {
          const idx = activePuzzleIdx;
          if (idx == null) return;

          subtitles[idx].solved = true;

          // следующий субтитр — следующий индекс
          nextIdx = Math.max(nextIdx, idx + 1);

          activePuzzleIdx = null;
          showPuzzleUI(false);

          ytPlayer?.playVideo?.();
        }, 450);
      } else {
        const total = originalText.split(/\s+/).filter(Boolean).length;
        $("feedback").innerHTML = `<span class="muted">Собрано: ${userSentence.length}/${total}</span>`;
      }
    }

    function playSnippet(idx, offsetSeconds = 0) {
      if (!ytPlayer?.seekTo) return;
      if (idx == null || idx < 0 || idx >= subtitles.length) return;

      snippetResumePuzzle = (activePuzzleIdx != null && activePuzzleIdx === idx);

      const s = subtitles[idx];

      snippetMode = true;
      snippetIdx = idx;
      snippetEnd = s.end;

      // прячем паззл на время прослушивания
      showPuzzleUI(false);

      const start = Math.max(0, s.start + offsetSeconds);
      ytPlayer.seekTo(start, true);
      ytPlayer.playVideo();
    }

    function tick() {
      if (!ytPlayer?.getCurrentTime) return;
      if (!subtitles.length) return;

      const t = ytPlayer.getCurrentTime();

      // если слушаем фрагмент — в конце останавливаем и возвращаем паззл того же индекса
      if (snippetMode) {
  if (t >= snippetEnd - 0.05) {
    snippetMode = false;
    ytPlayer.pauseVideo();

    if (snippetResumePuzzle) {
      showPuzzleUI(true);
    } else {
      initPuzzleByIndex(snippetIdx);
    }
  }
  return;
}


      // пропускаем уже решённые
      while (nextIdx < subtitles.length && subtitles[nextIdx].solved) nextIdx++;

      if (nextIdx >= subtitles.length) return;

      const s = subtitles[nextIdx];

      // ждём, пока дойдём до конца текущей фразы
      if (t >= s.end - 0.05) {
        initPuzzleByIndex(nextIdx);
      }
    }

    function onStateChange(e) {
      if (e.data === YT.PlayerState.PLAYING) {
        const t = ytPlayer?.getCurrentTime?.() ?? 0;
    syncNextIdxToTime(t);
        if (tickTimer) return;
        tickTimer = setInterval(tick, 120);
      } else {
        if (tickTimer) {
          clearInterval(tickTimer);
          tickTimer = null;
        }
      }
    }

    window.onYouTubeIframeAPIReady = function () {
      ytPlayer = new YT.Player("player", {
        height: "360",
        width: "640",
        playerVars: {
          playsinline: 1,
          origin: location.origin
        },
        events: {
          onReady: () => {
            playerReady = true;
            console.log("YouTube player is ready");
          },
          onStateChange: onStateChange
        }
      });
    };

    $("load").onclick = () => {
  const id = extractId($("vid").value);

  if (!playerReady) {
    alert("Плеер YouTube ещё не готов. Запускай страницу через localhost (Live Server), не через file://");
    return;
  }

  if (!id) return;

  // сброс прогресса
  nextIdx = 0;
  activePuzzleIdx = null;
  snippetMode = false;

  // ВАЖНО: грузим строго с 0 секунды
  ytPlayer.loadVideoById({
    videoId: id,
    startSeconds: 0
  });

  // и на всякий случай сразу синхронизируем nextIdx
  // (плеер может ещё не успеть обновить время, поэтому делаем через небольшой таймаут)
  setTimeout(() => {
    try {
      const t = ytPlayer.getCurrentTime?.() ?? 0;
      syncNextIdxToTime(t);
    } catch {}
  }, 300);
};


    $("srtFile").onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
  subtitles = parseSRT(event.target.result);

  // если видео уже играет / стоит не на нуле — подстроимся
  const t = ytPlayer?.getCurrentTime?.() ?? 0;
  syncNextIdxToTime(t);

  activePuzzleIdx = null;
  snippetMode = false;
};

      reader.readAsText(file);
    };

    $("listen-btn").onclick = () => {
      // слушаем текущий паззл (если паззла нет — слушаем nextIdx)
      const idx = (activePuzzleIdx != null) ? activePuzzleIdx : nextIdx;
      playSnippet(idx, 0);
    };

    $("listen-1s-btn").onclick = () => {
      const idx = (activePuzzleIdx != null) ? activePuzzleIdx : nextIdx;
      playSnippet(idx, -1);
    };

    $("skip-btn").onclick = () => {
      const idx = (activePuzzleIdx != null) ? activePuzzleIdx : nextIdx;
      if (idx == null || idx < 0 || idx >= subtitles.length) return;

      subtitles[idx].solved = true;
      nextIdx = Math.max(nextIdx, idx + 1);

      activePuzzleIdx = null;
      showPuzzleUI(false);
      ytPlayer?.playVideo?.();
    };

    function extractId(url) {
      if (!url) return null;
      const m = url.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|shorts\/)|youtu\.be\/)([\w-]{11})/);
      return m ? m[1] : url.trim();
    }

    const tag = document.createElement("script");
    tag.src = "https://www.youtube.com/iframe_api";
    document.body.appendChild(tag);
  </script>
</body>
</html>
